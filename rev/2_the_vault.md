# vault

ELF binary from `file`
`vault: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 4.4.0, stripped`

Opening with Ghidra.

main at 10c450
real "main" at 10c220
looks like a C++ binary

inside the check flag loop:
```c
    bVar2 = (***(&PTR_PTR_00117880)[ARRAY_0010e090[local_234]])();
    if (local_219 != bVar2) {
      bVar1 = false;
    }
```

it checks each byte of the 25 length flag with a function ptr table (probably also 25 long, one func for each)

2
0x23
0x25
0xc
0x27
0x63
0x67

each function produces 1 byte
e.g.
```asm
                                                                             00115578(*)  
      0010d440 55            PUSH      RBP
      0010d441 48 89 e5      MOV       RBP,RSP
      0010d444 48 89 7d      MOV       qword ptr [RBP + local_10],RDI
               f8
      0010d448 b0 1c         MOV       AL,0x1c
      0010d44a 0f b6 c0      MOVZX     EAX,AL
      0010d44d 5d            POP       RBP
      0010d44e c3            RET
      0010d44f 90            ??        90h
```




where local_234 is a counter between 0 to 25
so for each index 0..25, pick the `funcptrarray[datarray[index]]`
and dat array is ARRAY_0010e090:
`[ 0xe0, 0xd1, 0xbb, 0x27, 0xf6, 0x72, 0xdb, 0xa3, 0x83, 0xb9, 0x69, 0x23, 0xdb, 0x63, 0xb9, 0x23, 0x05, 0x2b, 0x2b, 0x83, 0x23, 0x39, 0x45, 0x39, 0x92 ]`
in int:
`[224, 209, 187, 39, 246, 114, 219, 163, 131, 185, 105, 35, 219, 99, 185, 35, 5, 43, 43, 131, 35, 57, 69, 57, 146]`

and the funcptrarray is about 256 long
extracting the Ghidra disassembly code and finding the bytes that each function returns: (rg is ripgrep)
```
rg -IN 'MOV       AL,0' ./disasm.txt |head
      0010c468 b0 02         MOV       AL,0x2
      0010c478 b0 23         MOV       AL,0x23
      0010c488 b0 25         MOV       AL,0x25
      0010c498 b0 0c         MOV       AL,0xc
      0010c4a8 b0 27         MOV       AL,0x27
      0010c4b8 b0 63         MOV       AL,0x63


```

getting them all out into an array:
```
rg -IN 'MOV       AL,0' ./disasm.txt |awk '{print $5}'|cut -d , -f2| tr '\n' ','
0x2,0x23,0x25,0xc,0x27,0x63,...
```
now we just have to arrange them according to the index array


weirdly enough, there's some off-by-one issue.

Here's the python console log:

```py
s = [224, 209, 187, 39, 246, 114, 219, 163, 131, 185, 105, 35, 219, 99, 185, 35, 5, 43, 43, 131, 35, 57, 69, 57, 146]
l = [0x2,0x23,0x25,0xc,0x27,0x63,0x67,0xc5,0xbe,0xe9,0x1a,0x45,0x28,0x3f,0x5a,0x96,0x4,0x8d,0x3b,0x58,0x6f,0x79,0xae,0x37,0xe1,0x59,0x3,0x9c,0x6a,0x8c,0xc1,0x49,0xa,0x8a,0x1,0x5f,0x19,0xed,0x93,0x7b,0xbd,0xef,0x94,0x30,0xfc,0x81,0xe5,0x26,0x31,0xfb,0x87,0x16,0x9e,0xd1,0xb3,0xb6,0x68,0xf9,0xc9,0x2f,0xa5,0x88,0x9a,0xf4,0x18,0xf0,0x40,0xce,0x75,0x71,0xa6,0xaa,0x56,0x86,0x2a,0xf1,0x47,0xd5,0x7f,0xee,0x78,0x52,0xb8,0x9b,0x1e,0x5b,0xb4,0x12,0xb0,0xf8,0x14,0xa7,0x6e,0xc7,0x1f,0xf7,0x21,0xea,0x72,0xe3,0xec,0xb1,0xb5,0x83,0x73,0xa9,0xff,0x53,0x7c,0xad,0x8e,0xa3,0x90,0x74,0xc8,0xd3,0x39,0xcf,0xd7,0x85,0x91,0xda,0x50,0x2c,0xd8,0xe7,0x80,0x61,0x5,0xfe,0x6c,0x10,0x7a,0xe2,0xcd,0x92,0x3c,0xf6,0xb9,0xe8,0x99,0xe,0xd0,0xdf,0x98,0x7d,0x6d,0x3d,0x17,0xac,0xa8,0x44,0xca,0xdd,0x64,0x4a,0x69,0x3e,0xd,0xd6,0x84,0xbc,0x62,0x97,0xdc,0x77,0xd9,0x8f,0xb,0x1d,0x13,0x5c,0xd4,0x41,0x22,0xab,0x11,0x60,0xc6,0xbf,0xe4,0xf3,0xde,0x7e,0x33,0x20,0x42,0xbb,0x5d,0x7,0xeb,0x43,0x65,0x82,0xc3,0xf2,0x4d,0x4c,0xaf,0xf,0x4e,0xe6,0x4b,0x9d,0x70,0x2b,0x1b,0x5e,0x54,0x57,0xd2,0xf5,0xc4,0xa1,0x24,0x9f,0x55,0xdb,0x34,0xcb,0x3a,0x36,0xcc,0x48,0xfd,0x46,0xe0,0x2e,0x38,0x66,0xfa,0x15,0xa2,0x89,0x8b,0x6b,0x35,0xc0,0x2d,0x51,0x32,0x29,0xc2,0x8,0xba,0x76,0xb2,0x4f,0x95,0xb7,0xa0,0x9,0x6,0x1c,0xa4]

# off by 1?
for i in s: print(chr(l[i-1]),end='')
... 
HTBvt4bl3s4r3'lhuh}

for i in s: print(chr(l[i]),end='')
... 
ýW»{²ÈË ©_Ëã _c00_ùqùm
# puzzling..
>>> res
'ýW»{²ÈË\x97\x10 ©_Ëã _c00\x10_ùqùm'
>>> res1
"HTB\x93vt4bl3s\x014r3\x01'\x94\x94l\x01huh}"
>>> len("HTB{vt4bl3s_4r3_c00l_huh}")
25

```

so flag is:
HTB{vt4bl3s_4r3_c00l_huh}
